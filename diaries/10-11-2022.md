# 10-11-2022

I've neglected a very important functionality so far: Cycles. Every CPU has a certain number of instructions that can be executed per clock cycle, 
and those clock cycles occur a certain amount of times per second. For example, we could have a CPU that executes 1 instruction per clock cycle 
and have a speed of 3 clock cycles per second. 

In chip8's case, each clock cycle, the CPU fetches the next instruction, decodes it, and executes the instruction. We can emulate this by creating
a Cycle function to fetch the next instruction, decode it, and execute it. Then, we can call this Cycle function a certain amount of times per
second. We control the clock speed because there was no clock speed specified in the chip8 reference. We can control it by defining a cycleDelay
constant. If we run the Cycle function in a while loop, every iteration we can check the time that elapsed since the last Cycle function was ran.
If more time than the cycleDelay constant elapsed, we can call the Cycle function again and update the appropriate variables. In the second case,
we can just go to the next iteration of the loop without calling Cycle.

I ran into an interesting problem while developing the cycle function. I was trying to extract the opcode from memory with the following code:

```
opcode = (memory[pc] << 8u) | memory[pc + 1]
```

opcode is 16 bits while the elements in memory are 8 bits each. I was confused on what `memory[pc] << 8u` would do because the element is only
8 bits long. There could be two cases: the expression results in 0 because all the bits get shifted out, or the expression expands to a size
large enough to store the bits shifted left. I did a little searching online and asking on a programming discord server to figure out the
rule cpp uses for cases like this. I got a reply "anything smaller than int is promoted to int before any arithmetic operation iirc". Also, 
a stack overflow post had a similar statement. It turns out that all integer types less than type int is **promoted to an int** before 
**any arithmetic operation**.

function pointer syntax
void (*foo)(int);
- foo is a pointer to a function taking one arg of an integer that returns void.

```
#include <stdio.h>
void my_int_func(int x)
{
    printf( "%d\n", x );
}
 
int main()
{
    void (*foo)(int);
    /* the ampersand is actually optional */
    foo = &my_int_func;
 
    return 0;
}
```

```

    void I_0(){
        functions0[opcode & 0xFF]();
    }

```

https://stackoverflow.com/questions/68174660/function-pointer-expression-preceding-parentheses-of-apparent-call-must-have
https://stackoverflow.com/questions/19555121/how-to-get-current-timestamp-in-milliseconds-since-1970-just-the-way-java-gets

https://www.cprogramming.com/tutorial/function-pointers.html
https://stackoverflow.com/questions/24370732/what-does-natural-size-really-mean-in-c
https://www.techopedia.com/definition/5498/clock-cycle